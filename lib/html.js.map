{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/html.coffee"
  ],
  "names": [],
  "mappings": "AACA;EAAA;AAAA,MAAA,GAAA,EAAA,QAAA,EAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAAA,KAAA,EAAA,KAAA,EAAA,IAAA,EAAA,sBAAA,EAAA,MAAA,EAAA,IAAA,EAAA,IAAA,EAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,IAAA,EAAA,GAAA,EAAA,SAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,EAAA,OAAA,EAAA,KAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,EAAA,OAAA;;;EAGA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,GAAA,GAA4B,GAAG,CAAC;;EAChC,KAAA,GAA4B;;EAC5B,GAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,OAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,SAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,IAAI,CAAC,IAAT,CAAc,GAAd;;EAC5B,CAAA,CAAE,EAAF,CAAA,GAA4B,GAA5B,EAfA;;;EAiBA,KAAA,GAA4B,IAAI,CAAE,OAAA,CAAQ,OAAR,CAAF,CAAmB,CAAC,KAAxB,CAA8B;IAAE,KAAA,EAAO;EAAT,CAA9B;;EAC5B,CAAA,CAAE,SAAF,EACE,IADF,EAEE,MAFF,EAGE,IAHF,EAIE,SAJF,EAKE,MALF,CAAA,GAK4B,KAAK,CAAC,MAAN,CAAA,CAL5B;;EAMA,KAAA,GAA4B,OAAA,CAAQ,SAAR,EAxB5B;;;;;;;;;EAyBA,CAAA,CAAE,GAAF,EACE,QADF,EASE,OATF,CAAA,GAS4B,KAT5B,EAzBA;;;EAoCA,CAAA,CAAE,QAAF,CAAA,GAA4B,OAAA,CAAQ,UAAR,CAA5B;;EACA,MAAA,GAA4B,MAAM,CAAC;;EACnC,sBAAA,GAA4B,CAAE,EAAF,EAAM,IAAN,EAAY,MAAZ;;EAtC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'INTERTEXT/HTML'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n{ jr, }                   = CND\n#...........................................................................................................\nDATOM                     = new ( require 'datom' ).Datom { dirty: false, }\n{ new_datom\n  lets\n  freeze\n  thaw\n  is_frozen\n  select }                = DATOM.export()\ntypes                     = require './types'\n{ isa\n  validate\n  # cast\n  # declare\n  # declare_cast\n  # check\n  # sad\n  # is_sad\n  # is_happy\n  type_of }               = types\n#...........................................................................................................\n{ Cupofjoe }              = require 'cupofjoe'\nassign                    = Object.assign\nexcluded_content_parts    = [ '', null, undefined, ]\n\n\n#===========================================================================================================\n#\n# #-----------------------------------------------------------------------------------------------------------\n# @_escape_text = ( x ) ->\n#   R           = x\n#   R           = R.replace /&/g,   '&amp;'\n#   R           = R.replace /</g,   '&lt;'\n#   R           = R.replace />/g,   '&gt;'\n#   return R\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_as_attribute_literal = ( x ) ->\n#   R           = if isa.text x then x else JSON.stringify x\n#   must_quote  = not isa._intertext_html_naked_attribute_text R\n#   R           = @_escape_text R\n#   R           = R.replace /'/g,   '&#39;'\n#   R           = R.replace /\\n/g,  '&#10;'\n#   R           = \"'\" + R + \"'\" if must_quote\n#   return R\n\n###\n#-----------------------------------------------------------------------------------------------------------\n@_parse_compact_tagname = ( compact_tagname ) ->\n  { tagname\n    attributes }  = ( compact_tagname.match /^(?<tagname>[^#.]*)(?<attributes>.*)$/ ).groups\n  R               = {}\n  R.tagname       = tagname unless tagname is ''\n  return R if attributes is ''\n  for attribute in attributes.split /([#.][^#.]*)/\n    continue if attribute is ''\n    avalue = attribute[ 1 .. ]\n    unless avalue.length > 0\n      throw new Error \"^intertext/_parse_compact_tagname@1234^ illegal compact tag syntax in #{rpr compact_tagname}\"\n    if attribute[ 0 ] is '#' then R.id = avalue\n    else                          ( R.class ?= [] ).push avalue\n  R.class = R.class.join ' ' if R.class?\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@tag = ( compact_tagname, attributes, content... ) ->\n  { start, content, end, } = @_tag compact_tagname, attributes, content\n  return [ start, content..., end, ] if end?\n  return [ start, content..., ]\n\n#-----------------------------------------------------------------------------------------------------------\n@_tag = ( compact_tagname, attributes, content, settings ) ->\n  validate.nonempty_text compact_tagname\n  { tagname, id, class: clasz, }  = @_parse_compact_tagname compact_tagname\n  validate.intertext_html_tagname tagname\n  use_attributes                  = false\n  processed_content               = []\n  call_functions                  = settings?.call_functions ? true\n  content                         = thaw content if ( Object.isFrozen content )\n  #.........................................................................................................\n  if attributes?\n    if isa.object attributes then use_attributes = true\n    else                          content.unshift attributes\n  #.........................................................................................................\n  if content.length is 0\n    sigil   = '^'\n    end_tag = null\n  #.........................................................................................................\n  else\n    sigil   = '<'\n    end_tag = new_datom \">#{tagname}\"\n    for part in content\n      continue if part in excluded_content_parts\n      switch type_of part\n        when 'text'     then  processed_content.push new_datom '^text', { text: part, }\n        when 'function'\n          if call_functions then  processed_content.push x unless ( x = part() ) in excluded_content_parts\n          else                    processed_content.push part\n        else                  processed_content.push part\n  #.........................................................................................................\n  if id? or clasz?\n    idclass         = {}\n    idclass.id      = id    if id?\n    idclass.class   = clasz if clasz?\n    if use_attributes\n      attributes = assign idclass, attributes\n    else\n      use_attributes  = true\n      attributes      = idclass\n  #.........................................................................................................\n  if use_attributes then  start_tag = new_datom \"#{sigil}#{tagname}\", attributes\n  else                    start_tag = new_datom \"#{sigil}#{tagname}\"\n  #.........................................................................................................\n  processed_content = processed_content.flat Infinity\n  return { start: start_tag, content: processed_content, end: end_tag, } if end_tag?\n  return { start: start_tag, content: processed_content, }\n###\n\n# #-----------------------------------------------------------------------------------------------------------\n# @html_from_datoms   = ( ds, settings ) -> return ( @_html_from_datom d for d in ds.flat Infinity ).join ''\n\n# #-----------------------------------------------------------------------------------------------------------\n# @$html_from_datoms  = ->\n#   { $, } = ( require 'steampipes' ).export()\n#   return $ ( d, send ) =>\n#     return send @_html_from_datom d unless isa.list d\n#     send x for x in @html_from_datoms d...\n#     return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_html_from_datom = ( d ) ->\n#   return @_html_from_datom ( @text d )[ 0 ] if isa.text d ### TAINT ??? ###\n#   DATOM.types.validate.datom_datom d\n#   atxt          = ''\n#   sigil         = d.$key[ 0 ]\n#   tagname       = d.$key[ 1 .. ]\n#   is_empty_tag  = isa._intertext_html_empty_element_tagname tagname\n#   x_key         = null\n#   is_block_tag  = d.$blk ? false\n#   bnl           = if is_block_tag then '\\n\\n' else ''   ### TAINT make configurable ###\n#   xnl           = '\\n'                                  ### TAINT make configurable ###\n#   #.........................................................................................................\n#   ### TAINT simplistic solution; namespace might already be taken? ###\n#   if sigil in '[~]'\n#     switch sigil\n#       when '[' then sigil = '<'\n#       when '~' then sigil = '^'\n#       when ']' then sigil = '>'\n#     [ x_key, tagname, ] = [ tagname, 'x-sys', ]\n#   #.........................................................................................................\n#   return ( @_escape_text d.text ? '' )            if ( sigil is '^' ) and ( tagname is 'text'     )\n#   return (               d.text ? '' )            if ( sigil is '^' ) and ( tagname is 'raw'      )\n#   return \"<!DOCTYPE #{d.$value ? 'html'}>#{xnl}\"  if ( sigil is '^' ) and ( tagname is 'doctype'  )\n#   return \"</#{tagname}>#{bnl}\"                    if sigil is '>'\n#   #.........................................................................................................\n#   ### NOTE sorting atxt by keys to make result predictable: ###\n#   if isa.object d.$value then  src = d.$value\n#   else                          src = d\n#   atxt += \" x-key=#{@_as_attribute_literal x_key}\" if x_key?\n#   for key in ( Object.keys src ).sort()\n#     continue if key.startsWith '$'\n#     if ( value = src[ key ] ) is true then  atxt += \" #{key}\"\n#     else                                    atxt += \" #{key}=#{@_as_attribute_literal value}\"\n#   #.........................................................................................................\n#   ### TAINT make self-closing elements configurable, depend on HTML5 type ###\n#   slash     = if ( sigil is '<' ) or is_empty_tag then '' else \"</#{tagname}>#{bnl}\"\n#   x_sys_key = if x_key? then \"<x-sys-key>#{x_key}</x-sys-key>\" else ''\n#   return \"<#{tagname}>#{slash}#{x_sys_key}\" if atxt is ''\n#   return \"<#{tagname}#{atxt}>#{x_sys_key}#{slash}\"\n\n\n\n\n\n"
  ]
}