{
  "version": 3,
  "file": "slabs.js",
  "sourceRoot": "..",
  "sources": [
    "src/slabs.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n###\n\n'Slab': the part of a word that is separated from others by breakpoints\n\n> The addressable unit of memory on the NCR 315 series is a \"slab\", short for \"syllable\", consisting of 12\n> data bits and a parity bit. Its size falls between a byte and a typical word (hence the name, 'syllable').\n> A slab may contain three digits (with at sign, comma, space, ampersand, point, and minus treated as\n> digits) or two alphabetic characters of six bits each.—[Wikipedia, \"NCR\n> 315\"](https://en.wikipedia.org/wiki/NCR_315)\n\n###\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'INTERTEXT/SLABS'\ndebug                     = CND.get_logger 'debug',     badge\nalert                     = CND.get_logger 'alert',     badge\nwhisper                   = CND.get_logger 'whisper',   badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\ninfo                      = CND.get_logger 'info',      badge\nPATH                      = require 'path'\nFS                        = require 'fs'\n{ jr, }                   = CND\nassign                    = Object.assign\njoin_path                 = ( P... ) -> PATH.resolve PATH.join P...\n#...........................................................................................................\ntypes                     = require './types'\n{ isa\n  validate\n  cast\n  type_of }               = types\nSP                        = require 'steampipes'\n{ $\n  $drain }                = SP.export()\nDATOM                     = require 'datom'\n{ new_datom\n  select }                = DATOM.export()\nINTERTEXT                 = null\nLineBreaker               = null\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\n@slabs_from_text = ( text ) ->\n  ### NOTE\n\n  Currently we use three single-character `end` markers:\n\n  * `x`—'none': nothing (empty string) whether non-final or final\n  * `_`—'space': space (U+0020) when non-final, nothing (empty string) when final\n  * `|`—'hyphen': nothing when non-final, add hyphen (U+002d) when final\n\n  ###\n  ### TAINT why doesn't import in top level work? ###\n  INTERTEXT    ?= require '..'\n  ### TAINT benchmark against https://github.com/hfour/linebreak-ts ###\n  LineBreaker  ?= require 'linebreak'\n  line_breaker  = new LineBreaker text\n  #.........................................................................................................\n  shy           = INTERTEXT.HYPH.soft_hyphen_chr\n  spc           = '\\x20'\n  prv_position  = 0\n  slabs         = []\n  ends          = []\n  R             = { slabs, ends, }\n  #.........................................................................................................\n  ### LBO: line break opportunity ###\n  while ( lbo = line_breaker.nextBreak() )?\n    end           = 'x'\n    slab          = text[ prv_position ... lbo.position ]\n    prv_position  = lbo.position\n    last_idx      = slab.length - 1\n    #.......................................................................................................\n    switch slab[ last_idx ]\n      when shy then [ end, slab, ] = [ '|', slab[ ... last_idx ], ]\n      ### TAINT in the future, we might want to consider other breaking (fixed or variable) spaces ###\n      when spc then [ end, slab, ] = [ '_', slab[ ... last_idx ], ]\n    #.......................................................................................................\n    slabs.push  slab\n    ends.push   end\n  #.........................................................................................................\n  R.ends = R.ends.join ''\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@assemble = ( me, first_idx = null, last_idx = null ) ->\n  ### TAINT validate indexes? ###\n  first_idx  ?= 0\n  last_idx   ?= me.slabs.length - 1\n  first_idx   = Math.max first_idx, 0\n  last_idx    = Math.min last_idx, me.slabs.length - 1\n  R           = ''\n  #.........................................................................................................\n  for idx in [ first_idx .. last_idx ] by +1\n    R += me.slabs[ idx ]\n    switch end = me.ends[ idx ]\n      when 'x'  then null\n      when '_'  then ( if idx isnt last_idx then R+= '\\x20' )\n      ### TAINT allow to configure hyphen ###\n      when '|'  then ( if idx is last_idx then R+= '-' )\n      else throw new Error \"^INTERTEXT/SLABS@4352^ unknown slab `end` option #{rpr end}\"\n  #.........................................................................................................\n  return R\n\n\n\n"
  ]
}